# Advent of Code - 2023 Day 08

Part 1 沒有什麼好說的。

Part 2 有些 tricky。因為輸入資料經過特別設計，符合某些條件，才能利用這個演算法找到答案。如果只是隨機的資料，就只能靠 brutal-force 硬跑。但這些條件又沒有在題目中指明，必須透過實驗得知。

輸入資料經過整理後，可以找到 6 個 `__A` 的起點（假設為 `11A` ~ `66A`），以及 6 個 `__Z` 的終點（假設為 `11Z` ~ `66Z`）。而這些資料剛好符合下面這些條件：

1. 每個起點一定能走到一個終點。
2. 這些起點和終點剛好是 1-to-1 的關係。例如：`11A` 如果會走到 `33Z`，那其他的 `__A` 絕對不會走到 `33Z`。
3. 從起點開始，第一次遇到終點時，所使用的步數一定是 instructions（也就是 `LR` 字串）長度的倍數。這點很重要。這表示如果從終點繼續再走，一定是依照相同的 instructions 走下去。
4. 從終點開始，再依照 instructions 繼續走下去，一定能再回到自己；而且所使用的步數，一定和「從對應的起點開始走回來」所使用的步數相同。

例如：輸入資料的 instructions 長度為 281。從 `KNA` 出發可以走到 `GNZ`，步數為 22199，剛好是 281 的倍數。從 `GNZ` 出發再走 22199 步，又可以回到 `GNZ`。

所以結論就是：從每一個起點開始走的路徑，每經過一個（各自）固定的步數後，就一定會走到終點。

因此，我們要求的，就是這些「固定步數」的最小公倍數。
