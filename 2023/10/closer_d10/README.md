# Advent of Code - 2023 Day 10

## Part 1

乍看之下是 shortest path 的題型，但其實單純很多。

題目已經說了，從 S 開始走，結果會是 loop。而且每一個 node 都只有兩個出入口（一進一出），所以從 S 走到最遠的點只有一條路，而且距離剛好是繞一圈所需步數的一半。或者是從 S 開始，同時往兩個方向走，走到碰頭的地方就是最遠的點（我就是用這個方法）。

## Part 2

基本的想法是：針對每一個 row，從左開始往右邊走。一開始的位置是在 loop 外面，碰到（或是跨過）loop 的線時，就會變成 loop 裡面。再碰到一次，又會到 loop 外面。依此類推。

剩下的問題就是「要如何判斷已經跨過線」了。由於 loop 的圖型是完美連接的，因此只會遇到下面三種狀況：

1. `"|"` → 就是跨過線了，沒有問題。
2. `"F----J"` 或 `"L----7"` → 跨過線。
3. `"F----7"` 或 `"L----J"` → 沒有跨過線。

經過歸納後，我找到的規律是：每一個 grid 都可以去判斷有沒有「往上的出口」以及「往下的出口」。必須要累積有「一個往上」及「一個往下」，才能算是越線一次。用這個概念來看上面的三種狀況：

1. `"|"` → 同時有往上和往下，所以有越線。
2. `"F----J"` 或 `"L----7"` → `F` 有往下的出口，`J` 有往上的出口，因此累積起來就是越線一次。`L` 和 `7` 亦同。
3. `"F----7"` 或 `"L----J"` → `F` 和 `7` 都是往下的出口，搭配在一起就沒有跨過線。`L` 和 `J` 亦同。

所以只要找到 loop 的 path 後，就可以掃一次去判斷每一個非 loop 的點是否在 loop 內。
